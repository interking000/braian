generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// SQLite: sin enums nativos en tu entorno.
// Validamos valores tipo "DEMO|ACTIVE|EXPIRED" desde Zod/TS.

model User {
  id         String   @id @default(uuid())
  username   String   @unique
  password   String
  email      String   @unique
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  // CONTROL DE ACCESO
  // DEMO | ACTIVE | EXPIRED
  access_status String @default("DEMO")

  // Demo: 12h desde registro
  trial_ends_at DateTime?

  // Acceso pago (cuando MP confirma)
  access_ends_at  DateTime?
  last_payment_at DateTime?

  // Plazo de pago / borrado (2 días luego de vencer)
  grace_delete_at DateTime?

  // Auditoría simple (cuántas veces cambió datos de acceso)
  access_edit_count   Int      @default(0)
  access_last_edit_at DateTime?

  AppText         AppText[]
  Category        Category[]
  AppConfig       AppConfig[]
  AppLayout       AppLayout[]
  AppNotification AppNotification[]

  Payment     Payment[]
  AccessEvent AccessEvent[]

  @@index([access_status])
  @@index([trial_ends_at])
  @@index([access_ends_at])
  @@index([grace_delete_at])
  @@index([last_payment_at])
  @@map("users")
}

model Category {
  id         Int      @id @default(autoincrement())
  name       String
  color      String
  sorter     Int
  status     String
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  user_id    String

  Config AppConfig[]

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([user_id])
  @@map("categories")
}

model AppConfig {
  id                     Int      @id @default(autoincrement())
  auth_password          String?
  auth_username          String?
  auth_v2ray_uuid        String?
  category_id            Int
  config_openvpn         String?
  config_payload_payload String?
  config_payload_sni     String?
  config_v2ray           String?
  description            String?
  dns_server_dns1        String?
  dns_server_dns2        String?
  icon                   String
  mode                   String
  name                   String
  proxy_host             String?
  proxy_port             Int?
  server_host            String?
  server_port            Int?
  sorter                 Int
  status                 String
  tls_version            String?
  udp_ports              String?
  created_at             DateTime @default(now())
  updated_at             DateTime @updatedAt
  url_check_user         String?
  user_id                String

  user     User     @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  category Category @relation(fields: [category_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([user_id])
  @@index([category_id])
  @@map("app_configs")
}

model AppText {
  id      Int    @id @default(autoincrement())
  label   String
  text    String
  user_id String

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([user_id])
  @@map("app_texts")
}

model AppLayout {
  id             Int                @id @default(autoincrement())
  user_id        String
  is_active      Boolean            @default(false)
  created_at     DateTime           @default(now())
  updated_at     DateTime?          @updatedAt
  layout_storage AppLayoutStorage[]

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([user_id])
  @@index([is_active])
  @@map("app_layouts")
}

model AppLayoutStorage {
  id            Int      @id @default(autoincrement())
  label         String
  name          String
  status        String
  type          String
  value         String?
  created_at    DateTime @default(now())
  updated_at    DateTime? @updatedAt
  app_layout_id Int

  app_layout AppLayout @relation(fields: [app_layout_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([app_layout_id])
  @@index([type])
  @@map("app_layout_storages")
}

model AppNotification {
  id Int @id @default(autoincrement())

  title    String
  subtitle String?
  message  String
  link     String?
  image    String?

  scheduled_at DateTime?

  starts_at            DateTime  @default(now())
  repeat_every_minutes Int?
  repeat_until         DateTime?
  next_send_at         DateTime  @default(now())
  last_sent_at         DateTime?
  sent_count           Int       @default(0)

  status     String   @default("ACTIVE")
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  user_id String
  user    User @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([user_id])
  @@index([next_send_at])
  @@map("app_notifications")
}

// Planes para no hardcodear precios/días
// code: "1M" | "2M" | "3M"
model Plan {
  id          Int      @id @default(autoincrement())
  code        String   @unique
  name        String
  days        Int
  price_ars   Int
  is_active   Boolean  @default(true)
  description String?
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  payments Payment[]

  @@index([is_active])
  @@map("plans")
}

// Pagos Mercado Pago
// provider: "MERCADOPAGO"
// status: "PENDING" | "APPROVED" | "REJECTED" | "CANCELLED" | "REFUNDED" | "CHARGEDBACK"
model Payment {
  id Int @id @default(autoincrement())

  user_id  String
  provider String @default("MERCADOPAGO")
  status   String @default("PENDING")

  plan_id Int
  plan    Plan @relation(fields: [plan_id], references: [id], onDelete: Restrict, onUpdate: Cascade)

  plan_code String
  days      Int
  amount    Int
  currency  String @default("ARS")

  mp_payment_id        String? @unique
  mp_preference_id     String?
  mp_merchant_order_id String?

  external_reference String?
  description        String?

  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt
  approved_at DateTime?

  mp_raw String?

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  access_events AccessEvent[]

  @@index([user_id])
  @@index([plan_id])
  @@index([status])
  @@index([provider])
  @@index([created_at])
  @@map("payments")
}

// Eventos de auditoría (type como string)
model AccessEvent {
  id Int @id @default(autoincrement())

  user_id String
  type    String

  payment_id Int?
  payment    Payment? @relation(fields: [payment_id], references: [id], onDelete: SetNull, onUpdate: Cascade)

  message String?

  prev_access_ends_at DateTime?
  new_access_ends_at  DateTime?

  created_at DateTime @default(now())

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([user_id])
  @@index([type])
  @@index([payment_id])
  @@index([created_at])
  @@map("access_events")
}
